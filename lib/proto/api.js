"use strict";
// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v1.180.0
//   protoc               v5.27.2
// source: api.proto
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.RPCMessages = exports.RPCMessage = exports.InitRequest = exports.ClaimTunnelResponse_Signatures = exports.ClaimTunnelResponse = exports.ClaimTunnelRequest_TranscriptMessage = exports.ClaimTunnelRequest_Signatures = exports.ClaimTunnelRequest = exports.ClaimRequestData = exports.MessageReveal_ZKProof = exports.MessageReveal_MessageRevealZk = exports.MessageReveal_MessageRevealDirect = exports.MessageReveal = exports.TunnelDisconnectEvent = exports.TunnelMessage = exports.Empty = exports.DisconnectTunnelRequest = exports.CreateTunnelRequest = exports.WitnessErrorData = exports.BeaconIdentifier = exports.ProviderClaimInfo = exports.ProviderClaimData = exports.ClaimContext_ExtractedParametersEntry = exports.ClaimContext = exports.ZKProofEngine = exports.WitnessErrorCode = exports.BeaconType = exports.WitnessVersion = exports.ServiceSignatureType = exports.TranscriptMessageSenderType = exports.protobufPackage = void 0;
exports.transcriptMessageSenderTypeFromJSON = transcriptMessageSenderTypeFromJSON;
exports.transcriptMessageSenderTypeToJSON = transcriptMessageSenderTypeToJSON;
exports.serviceSignatureTypeFromJSON = serviceSignatureTypeFromJSON;
exports.serviceSignatureTypeToJSON = serviceSignatureTypeToJSON;
exports.witnessVersionFromJSON = witnessVersionFromJSON;
exports.witnessVersionToJSON = witnessVersionToJSON;
exports.beaconTypeFromJSON = beaconTypeFromJSON;
exports.beaconTypeToJSON = beaconTypeToJSON;
exports.witnessErrorCodeFromJSON = witnessErrorCodeFromJSON;
exports.witnessErrorCodeToJSON = witnessErrorCodeToJSON;
exports.zKProofEngineFromJSON = zKProofEngineFromJSON;
exports.zKProofEngineToJSON = zKProofEngineToJSON;
/* eslint-disable */
const long_1 = __importDefault(require("long"));
const minimal_1 = __importDefault(require("protobufjs/minimal"));
exports.protobufPackage = "reclaim_witness";
var TranscriptMessageSenderType;
(function (TranscriptMessageSenderType) {
    TranscriptMessageSenderType[TranscriptMessageSenderType["TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN"] = 0] = "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN";
    TranscriptMessageSenderType[TranscriptMessageSenderType["TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT"] = 1] = "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT";
    TranscriptMessageSenderType[TranscriptMessageSenderType["TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER"] = 2] = "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER";
    TranscriptMessageSenderType[TranscriptMessageSenderType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(TranscriptMessageSenderType || (exports.TranscriptMessageSenderType = TranscriptMessageSenderType = {}));
function transcriptMessageSenderTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN":
            return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN;
        case 1:
        case "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT":
            return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT;
        case 2:
        case "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER":
            return TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER;
        case -1:
        case "UNRECOGNIZED":
        default:
            return TranscriptMessageSenderType.UNRECOGNIZED;
    }
}
function transcriptMessageSenderTypeToJSON(object) {
    switch (object) {
        case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN:
            return "TRANSCRIPT_MESSAGE_SENDER_TYPE_UNKNOWN";
        case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT:
            return "TRANSCRIPT_MESSAGE_SENDER_TYPE_CLIENT";
        case TranscriptMessageSenderType.TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER:
            return "TRANSCRIPT_MESSAGE_SENDER_TYPE_SERVER";
        case TranscriptMessageSenderType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var ServiceSignatureType;
(function (ServiceSignatureType) {
    ServiceSignatureType[ServiceSignatureType["SERVICE_SIGNATURE_TYPE_UNKNOWN"] = 0] = "SERVICE_SIGNATURE_TYPE_UNKNOWN";
    /**
     * SERVICE_SIGNATURE_TYPE_ETH - ETH keys & signature
     * keys: secp256k1
     * signature: ethereum flavor of ECDSA (https://goethereumbook.org/signature-generate/)
     */
    ServiceSignatureType[ServiceSignatureType["SERVICE_SIGNATURE_TYPE_ETH"] = 1] = "SERVICE_SIGNATURE_TYPE_ETH";
    ServiceSignatureType[ServiceSignatureType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ServiceSignatureType || (exports.ServiceSignatureType = ServiceSignatureType = {}));
function serviceSignatureTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "SERVICE_SIGNATURE_TYPE_UNKNOWN":
            return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN;
        case 1:
        case "SERVICE_SIGNATURE_TYPE_ETH":
            return ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ServiceSignatureType.UNRECOGNIZED;
    }
}
function serviceSignatureTypeToJSON(object) {
    switch (object) {
        case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_UNKNOWN:
            return "SERVICE_SIGNATURE_TYPE_UNKNOWN";
        case ServiceSignatureType.SERVICE_SIGNATURE_TYPE_ETH:
            return "SERVICE_SIGNATURE_TYPE_ETH";
        case ServiceSignatureType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var WitnessVersion;
(function (WitnessVersion) {
    WitnessVersion[WitnessVersion["WITNESS_VERSION_UNKNOWN"] = 0] = "WITNESS_VERSION_UNKNOWN";
    WitnessVersion[WitnessVersion["WITNESS_VERSION_1_0_0"] = 1] = "WITNESS_VERSION_1_0_0";
    WitnessVersion[WitnessVersion["WITNESS_VERSION_1_1_0"] = 2] = "WITNESS_VERSION_1_1_0";
    WitnessVersion[WitnessVersion["WITNESS_VERSION_2_0_0"] = 3] = "WITNESS_VERSION_2_0_0";
    WitnessVersion[WitnessVersion["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WitnessVersion || (exports.WitnessVersion = WitnessVersion = {}));
function witnessVersionFromJSON(object) {
    switch (object) {
        case 0:
        case "WITNESS_VERSION_UNKNOWN":
            return WitnessVersion.WITNESS_VERSION_UNKNOWN;
        case 1:
        case "WITNESS_VERSION_1_0_0":
            return WitnessVersion.WITNESS_VERSION_1_0_0;
        case 2:
        case "WITNESS_VERSION_1_1_0":
            return WitnessVersion.WITNESS_VERSION_1_1_0;
        case 3:
        case "WITNESS_VERSION_2_0_0":
            return WitnessVersion.WITNESS_VERSION_2_0_0;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WitnessVersion.UNRECOGNIZED;
    }
}
function witnessVersionToJSON(object) {
    switch (object) {
        case WitnessVersion.WITNESS_VERSION_UNKNOWN:
            return "WITNESS_VERSION_UNKNOWN";
        case WitnessVersion.WITNESS_VERSION_1_0_0:
            return "WITNESS_VERSION_1_0_0";
        case WitnessVersion.WITNESS_VERSION_1_1_0:
            return "WITNESS_VERSION_1_1_0";
        case WitnessVersion.WITNESS_VERSION_2_0_0:
            return "WITNESS_VERSION_2_0_0";
        case WitnessVersion.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var BeaconType;
(function (BeaconType) {
    BeaconType[BeaconType["BEACON_TYPE_UNKNOWN"] = 0] = "BEACON_TYPE_UNKNOWN";
    BeaconType[BeaconType["BEACON_TYPE_SMART_CONTRACT"] = 1] = "BEACON_TYPE_SMART_CONTRACT";
    BeaconType[BeaconType["BEACON_TYPE_RECLAIM_TRUSTED"] = 2] = "BEACON_TYPE_RECLAIM_TRUSTED";
    BeaconType[BeaconType["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(BeaconType || (exports.BeaconType = BeaconType = {}));
function beaconTypeFromJSON(object) {
    switch (object) {
        case 0:
        case "BEACON_TYPE_UNKNOWN":
            return BeaconType.BEACON_TYPE_UNKNOWN;
        case 1:
        case "BEACON_TYPE_SMART_CONTRACT":
            return BeaconType.BEACON_TYPE_SMART_CONTRACT;
        case 2:
        case "BEACON_TYPE_RECLAIM_TRUSTED":
            return BeaconType.BEACON_TYPE_RECLAIM_TRUSTED;
        case -1:
        case "UNRECOGNIZED":
        default:
            return BeaconType.UNRECOGNIZED;
    }
}
function beaconTypeToJSON(object) {
    switch (object) {
        case BeaconType.BEACON_TYPE_UNKNOWN:
            return "BEACON_TYPE_UNKNOWN";
        case BeaconType.BEACON_TYPE_SMART_CONTRACT:
            return "BEACON_TYPE_SMART_CONTRACT";
        case BeaconType.BEACON_TYPE_RECLAIM_TRUSTED:
            return "BEACON_TYPE_RECLAIM_TRUSTED";
        case BeaconType.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var WitnessErrorCode;
(function (WitnessErrorCode) {
    /**
     * WITNESS_ERROR_NO_ERROR - 0 should be treated as the absence of an error
     * should be used when gracefully closing the connection
     */
    WitnessErrorCode[WitnessErrorCode["WITNESS_ERROR_NO_ERROR"] = 0] = "WITNESS_ERROR_NO_ERROR";
    /**
     * WITNESS_ERROR_INTERNAL - internal error in the witness -- all "Error/TypeError"
     * messages are mapped to this
     */
    WitnessErrorCode[WitnessErrorCode["WITNESS_ERROR_INTERNAL"] = 1] = "WITNESS_ERROR_INTERNAL";
    /** WITNESS_ERROR_BAD_REQUEST - bad request from the client */
    WitnessErrorCode[WitnessErrorCode["WITNESS_ERROR_BAD_REQUEST"] = 2] = "WITNESS_ERROR_BAD_REQUEST";
    /** WITNESS_ERROR_NOT_FOUND - the item requested was not found */
    WitnessErrorCode[WitnessErrorCode["WITNESS_ERROR_NOT_FOUND"] = 3] = "WITNESS_ERROR_NOT_FOUND";
    /** WITNESS_ERROR_PROXY_ERROR - error in the proxy */
    WitnessErrorCode[WitnessErrorCode["WITNESS_ERROR_PROXY_ERROR"] = 4] = "WITNESS_ERROR_PROXY_ERROR";
    /**
     * WITNESS_ERROR_INVALID_CLAIM - claim creation failed -- i.e. the transcript
     * did not result in a valid claim
     */
    WitnessErrorCode[WitnessErrorCode["WITNESS_ERROR_INVALID_CLAIM"] = 5] = "WITNESS_ERROR_INVALID_CLAIM";
    /** WITNESS_ERROR_NETWORK_ERROR - any network error */
    WitnessErrorCode[WitnessErrorCode["WITNESS_ERROR_NETWORK_ERROR"] = 6] = "WITNESS_ERROR_NETWORK_ERROR";
    WitnessErrorCode[WitnessErrorCode["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(WitnessErrorCode || (exports.WitnessErrorCode = WitnessErrorCode = {}));
function witnessErrorCodeFromJSON(object) {
    switch (object) {
        case 0:
        case "WITNESS_ERROR_NO_ERROR":
            return WitnessErrorCode.WITNESS_ERROR_NO_ERROR;
        case 1:
        case "WITNESS_ERROR_INTERNAL":
            return WitnessErrorCode.WITNESS_ERROR_INTERNAL;
        case 2:
        case "WITNESS_ERROR_BAD_REQUEST":
            return WitnessErrorCode.WITNESS_ERROR_BAD_REQUEST;
        case 3:
        case "WITNESS_ERROR_NOT_FOUND":
            return WitnessErrorCode.WITNESS_ERROR_NOT_FOUND;
        case 4:
        case "WITNESS_ERROR_PROXY_ERROR":
            return WitnessErrorCode.WITNESS_ERROR_PROXY_ERROR;
        case 5:
        case "WITNESS_ERROR_INVALID_CLAIM":
            return WitnessErrorCode.WITNESS_ERROR_INVALID_CLAIM;
        case 6:
        case "WITNESS_ERROR_NETWORK_ERROR":
            return WitnessErrorCode.WITNESS_ERROR_NETWORK_ERROR;
        case -1:
        case "UNRECOGNIZED":
        default:
            return WitnessErrorCode.UNRECOGNIZED;
    }
}
function witnessErrorCodeToJSON(object) {
    switch (object) {
        case WitnessErrorCode.WITNESS_ERROR_NO_ERROR:
            return "WITNESS_ERROR_NO_ERROR";
        case WitnessErrorCode.WITNESS_ERROR_INTERNAL:
            return "WITNESS_ERROR_INTERNAL";
        case WitnessErrorCode.WITNESS_ERROR_BAD_REQUEST:
            return "WITNESS_ERROR_BAD_REQUEST";
        case WitnessErrorCode.WITNESS_ERROR_NOT_FOUND:
            return "WITNESS_ERROR_NOT_FOUND";
        case WitnessErrorCode.WITNESS_ERROR_PROXY_ERROR:
            return "WITNESS_ERROR_PROXY_ERROR";
        case WitnessErrorCode.WITNESS_ERROR_INVALID_CLAIM:
            return "WITNESS_ERROR_INVALID_CLAIM";
        case WitnessErrorCode.WITNESS_ERROR_NETWORK_ERROR:
            return "WITNESS_ERROR_NETWORK_ERROR";
        case WitnessErrorCode.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
var ZKProofEngine;
(function (ZKProofEngine) {
    ZKProofEngine[ZKProofEngine["ZK_ENGINE_SNARKJS"] = 0] = "ZK_ENGINE_SNARKJS";
    ZKProofEngine[ZKProofEngine["ZK_ENGINE_GNARK"] = 1] = "ZK_ENGINE_GNARK";
    ZKProofEngine[ZKProofEngine["UNRECOGNIZED"] = -1] = "UNRECOGNIZED";
})(ZKProofEngine || (exports.ZKProofEngine = ZKProofEngine = {}));
function zKProofEngineFromJSON(object) {
    switch (object) {
        case 0:
        case "ZK_ENGINE_SNARKJS":
            return ZKProofEngine.ZK_ENGINE_SNARKJS;
        case 1:
        case "ZK_ENGINE_GNARK":
            return ZKProofEngine.ZK_ENGINE_GNARK;
        case -1:
        case "UNRECOGNIZED":
        default:
            return ZKProofEngine.UNRECOGNIZED;
    }
}
function zKProofEngineToJSON(object) {
    switch (object) {
        case ZKProofEngine.ZK_ENGINE_SNARKJS:
            return "ZK_ENGINE_SNARKJS";
        case ZKProofEngine.ZK_ENGINE_GNARK:
            return "ZK_ENGINE_GNARK";
        case ZKProofEngine.UNRECOGNIZED:
        default:
            return "UNRECOGNIZED";
    }
}
function createBaseClaimContext() {
    return { extractedParameters: {}, providerHash: "" };
}
exports.ClaimContext = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        Object.entries(message.extractedParameters).forEach(([key, value]) => {
            exports.ClaimContext_ExtractedParametersEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();
        });
        if (message.providerHash !== "") {
            writer.uint32(18).string(message.providerHash);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimContext();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    const entry1 = exports.ClaimContext_ExtractedParametersEntry.decode(reader, reader.uint32());
                    if (entry1.value !== undefined) {
                        message.extractedParameters[entry1.key] = entry1.value;
                    }
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.providerHash = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            extractedParameters: isObject(object.extractedParameters)
                ? Object.entries(object.extractedParameters).reduce((acc, [key, value]) => {
                    acc[key] = String(value);
                    return acc;
                }, {})
                : {},
            providerHash: isSet(object.providerHash) ? globalThis.String(object.providerHash) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.extractedParameters) {
            const entries = Object.entries(message.extractedParameters);
            if (entries.length > 0) {
                obj.extractedParameters = {};
                entries.forEach(([k, v]) => {
                    obj.extractedParameters[k] = v;
                });
            }
        }
        if (message.providerHash !== "") {
            obj.providerHash = message.providerHash;
        }
        return obj;
    },
    create(base) {
        return exports.ClaimContext.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseClaimContext();
        message.extractedParameters = Object.entries((_a = object.extractedParameters) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {
            if (value !== undefined) {
                acc[key] = globalThis.String(value);
            }
            return acc;
        }, {});
        message.providerHash = (_b = object.providerHash) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseClaimContext_ExtractedParametersEntry() {
    return { key: "", value: "" };
}
exports.ClaimContext_ExtractedParametersEntry = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key !== "") {
            writer.uint32(10).string(message.key);
        }
        if (message.value !== "") {
            writer.uint32(18).string(message.value);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimContext_ExtractedParametersEntry();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.value = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? globalThis.String(object.key) : "",
            value: isSet(object.value) ? globalThis.String(object.value) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key !== "") {
            obj.key = message.key;
        }
        if (message.value !== "") {
            obj.value = message.value;
        }
        return obj;
    },
    create(base) {
        return exports.ClaimContext_ExtractedParametersEntry.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseClaimContext_ExtractedParametersEntry();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : "";
        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseProviderClaimData() {
    return { provider: "", parameters: "", owner: "", timestampS: 0, context: "", identifier: "", epoch: 0 };
}
exports.ProviderClaimData = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.provider !== "") {
            writer.uint32(10).string(message.provider);
        }
        if (message.parameters !== "") {
            writer.uint32(18).string(message.parameters);
        }
        if (message.owner !== "") {
            writer.uint32(26).string(message.owner);
        }
        if (message.timestampS !== 0) {
            writer.uint32(32).uint32(message.timestampS);
        }
        if (message.context !== "") {
            writer.uint32(50).string(message.context);
        }
        if (message.identifier !== "") {
            writer.uint32(66).string(message.identifier);
        }
        if (message.epoch !== 0) {
            writer.uint32(72).uint32(message.epoch);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProviderClaimData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.provider = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.parameters = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.owner = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.timestampS = reader.uint32();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.context = reader.string();
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.identifier = reader.string();
                    continue;
                case 9:
                    if (tag !== 72) {
                        break;
                    }
                    message.epoch = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
            parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
            owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
            timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
            context: isSet(object.context) ? globalThis.String(object.context) : "",
            identifier: isSet(object.identifier) ? globalThis.String(object.identifier) : "",
            epoch: isSet(object.epoch) ? globalThis.Number(object.epoch) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.provider !== "") {
            obj.provider = message.provider;
        }
        if (message.parameters !== "") {
            obj.parameters = message.parameters;
        }
        if (message.owner !== "") {
            obj.owner = message.owner;
        }
        if (message.timestampS !== 0) {
            obj.timestampS = Math.round(message.timestampS);
        }
        if (message.context !== "") {
            obj.context = message.context;
        }
        if (message.identifier !== "") {
            obj.identifier = message.identifier;
        }
        if (message.epoch !== 0) {
            obj.epoch = Math.round(message.epoch);
        }
        return obj;
    },
    create(base) {
        return exports.ProviderClaimData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e, _f, _g;
        const message = createBaseProviderClaimData();
        message.provider = (_a = object.provider) !== null && _a !== void 0 ? _a : "";
        message.parameters = (_b = object.parameters) !== null && _b !== void 0 ? _b : "";
        message.owner = (_c = object.owner) !== null && _c !== void 0 ? _c : "";
        message.timestampS = (_d = object.timestampS) !== null && _d !== void 0 ? _d : 0;
        message.context = (_e = object.context) !== null && _e !== void 0 ? _e : "";
        message.identifier = (_f = object.identifier) !== null && _f !== void 0 ? _f : "";
        message.epoch = (_g = object.epoch) !== null && _g !== void 0 ? _g : 0;
        return message;
    },
};
function createBaseProviderClaimInfo() {
    return { provider: "", parameters: "", context: "" };
}
exports.ProviderClaimInfo = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.provider !== "") {
            writer.uint32(10).string(message.provider);
        }
        if (message.parameters !== "") {
            writer.uint32(18).string(message.parameters);
        }
        if (message.context !== "") {
            writer.uint32(50).string(message.context);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseProviderClaimInfo();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.provider = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.parameters = reader.string();
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.context = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
            parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
            context: isSet(object.context) ? globalThis.String(object.context) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.provider !== "") {
            obj.provider = message.provider;
        }
        if (message.parameters !== "") {
            obj.parameters = message.parameters;
        }
        if (message.context !== "") {
            obj.context = message.context;
        }
        return obj;
    },
    create(base) {
        return exports.ProviderClaimInfo.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseProviderClaimInfo();
        message.provider = (_a = object.provider) !== null && _a !== void 0 ? _a : "";
        message.parameters = (_b = object.parameters) !== null && _b !== void 0 ? _b : "";
        message.context = (_c = object.context) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseBeaconIdentifier() {
    return { type: 0, id: "" };
}
exports.BeaconIdentifier = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.type !== 0) {
            writer.uint32(8).int32(message.type);
        }
        if (message.id !== "") {
            writer.uint32(18).string(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseBeaconIdentifier();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.type = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.id = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            type: isSet(object.type) ? beaconTypeFromJSON(object.type) : 0,
            id: isSet(object.id) ? globalThis.String(object.id) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.type !== 0) {
            obj.type = beaconTypeToJSON(message.type);
        }
        if (message.id !== "") {
            obj.id = message.id;
        }
        return obj;
    },
    create(base) {
        return exports.BeaconIdentifier.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseBeaconIdentifier();
        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;
        message.id = (_b = object.id) !== null && _b !== void 0 ? _b : "";
        return message;
    },
};
function createBaseWitnessErrorData() {
    return { code: 0, message: "", data: "" };
}
exports.WitnessErrorData = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.code !== 0) {
            writer.uint32(8).int32(message.code);
        }
        if (message.message !== "") {
            writer.uint32(18).string(message.message);
        }
        if (message.data !== "") {
            writer.uint32(26).string(message.data);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseWitnessErrorData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.code = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.data = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            code: isSet(object.code) ? witnessErrorCodeFromJSON(object.code) : 0,
            message: isSet(object.message) ? globalThis.String(object.message) : "",
            data: isSet(object.data) ? globalThis.String(object.data) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.code !== 0) {
            obj.code = witnessErrorCodeToJSON(message.code);
        }
        if (message.message !== "") {
            obj.message = message.message;
        }
        if (message.data !== "") {
            obj.data = message.data;
        }
        return obj;
    },
    create(base) {
        return exports.WitnessErrorData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseWitnessErrorData();
        message.code = (_a = object.code) !== null && _a !== void 0 ? _a : 0;
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : "";
        message.data = (_c = object.data) !== null && _c !== void 0 ? _c : "";
        return message;
    },
};
function createBaseCreateTunnelRequest() {
    return { id: 0, host: "", port: 0, geoLocation: "" };
}
exports.CreateTunnelRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(8).uint32(message.id);
        }
        if (message.host !== "") {
            writer.uint32(18).string(message.host);
        }
        if (message.port !== 0) {
            writer.uint32(24).uint32(message.port);
        }
        if (message.geoLocation !== "") {
            writer.uint32(34).string(message.geoLocation);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseCreateTunnelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.host = reader.string();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.port = reader.uint32();
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.geoLocation = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            host: isSet(object.host) ? globalThis.String(object.host) : "",
            port: isSet(object.port) ? globalThis.Number(object.port) : 0,
            geoLocation: isSet(object.geoLocation) ? globalThis.String(object.geoLocation) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.host !== "") {
            obj.host = message.host;
        }
        if (message.port !== 0) {
            obj.port = Math.round(message.port);
        }
        if (message.geoLocation !== "") {
            obj.geoLocation = message.geoLocation;
        }
        return obj;
    },
    create(base) {
        return exports.CreateTunnelRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseCreateTunnelRequest();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : 0;
        message.host = (_b = object.host) !== null && _b !== void 0 ? _b : "";
        message.port = (_c = object.port) !== null && _c !== void 0 ? _c : 0;
        message.geoLocation = (_d = object.geoLocation) !== null && _d !== void 0 ? _d : "";
        return message;
    },
};
function createBaseDisconnectTunnelRequest() {
    return { id: 0 };
}
exports.DisconnectTunnelRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(8).uint32(message.id);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseDisconnectTunnelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.id = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        return obj;
    },
    create(base) {
        return exports.DisconnectTunnelRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseDisconnectTunnelRequest();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : 0;
        return message;
    },
};
function createBaseEmpty() {
    return {};
}
exports.Empty = {
    encode(_, writer = minimal_1.default.Writer.create()) {
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseEmpty();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(_) {
        return {};
    },
    toJSON(_) {
        const obj = {};
        return obj;
    },
    create(base) {
        return exports.Empty.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(_) {
        const message = createBaseEmpty();
        return message;
    },
};
function createBaseTunnelMessage() {
    return { tunnelId: 0, message: new Uint8Array(0) };
}
exports.TunnelMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tunnelId !== 0) {
            writer.uint32(8).uint32(message.tunnelId);
        }
        if (message.message.length !== 0) {
            writer.uint32(18).bytes(message.message);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTunnelMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.tunnelId = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
            message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tunnelId !== 0) {
            obj.tunnelId = Math.round(message.tunnelId);
        }
        if (message.message.length !== 0) {
            obj.message = base64FromBytes(message.message);
        }
        return obj;
    },
    create(base) {
        return exports.TunnelMessage.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseTunnelMessage();
        message.tunnelId = (_a = object.tunnelId) !== null && _a !== void 0 ? _a : 0;
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        return message;
    },
};
function createBaseTunnelDisconnectEvent() {
    return { tunnelId: 0, error: undefined };
}
exports.TunnelDisconnectEvent = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.tunnelId !== 0) {
            writer.uint32(8).uint32(message.tunnelId);
        }
        if (message.error !== undefined) {
            exports.WitnessErrorData.encode(message.error, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseTunnelDisconnectEvent();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.tunnelId = reader.uint32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.error = exports.WitnessErrorData.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            tunnelId: isSet(object.tunnelId) ? globalThis.Number(object.tunnelId) : 0,
            error: isSet(object.error) ? exports.WitnessErrorData.fromJSON(object.error) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.tunnelId !== 0) {
            obj.tunnelId = Math.round(message.tunnelId);
        }
        if (message.error !== undefined) {
            obj.error = exports.WitnessErrorData.toJSON(message.error);
        }
        return obj;
    },
    create(base) {
        return exports.TunnelDisconnectEvent.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseTunnelDisconnectEvent();
        message.tunnelId = (_a = object.tunnelId) !== null && _a !== void 0 ? _a : 0;
        message.error = (object.error !== undefined && object.error !== null)
            ? exports.WitnessErrorData.fromPartial(object.error)
            : undefined;
        return message;
    },
};
function createBaseMessageReveal() {
    return { directReveal: undefined, zkReveal: undefined };
}
exports.MessageReveal = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.directReveal !== undefined) {
            exports.MessageReveal_MessageRevealDirect.encode(message.directReveal, writer.uint32(10).fork()).ldelim();
        }
        if (message.zkReveal !== undefined) {
            exports.MessageReveal_MessageRevealZk.encode(message.zkReveal, writer.uint32(18).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageReveal();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.directReveal = exports.MessageReveal_MessageRevealDirect.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.zkReveal = exports.MessageReveal_MessageRevealZk.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            directReveal: isSet(object.directReveal)
                ? exports.MessageReveal_MessageRevealDirect.fromJSON(object.directReveal)
                : undefined,
            zkReveal: isSet(object.zkReveal) ? exports.MessageReveal_MessageRevealZk.fromJSON(object.zkReveal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.directReveal !== undefined) {
            obj.directReveal = exports.MessageReveal_MessageRevealDirect.toJSON(message.directReveal);
        }
        if (message.zkReveal !== undefined) {
            obj.zkReveal = exports.MessageReveal_MessageRevealZk.toJSON(message.zkReveal);
        }
        return obj;
    },
    create(base) {
        return exports.MessageReveal.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseMessageReveal();
        message.directReveal = (object.directReveal !== undefined && object.directReveal !== null)
            ? exports.MessageReveal_MessageRevealDirect.fromPartial(object.directReveal)
            : undefined;
        message.zkReveal = (object.zkReveal !== undefined && object.zkReveal !== null)
            ? exports.MessageReveal_MessageRevealZk.fromPartial(object.zkReveal)
            : undefined;
        return message;
    },
};
function createBaseMessageReveal_MessageRevealDirect() {
    return { key: new Uint8Array(0), iv: new Uint8Array(0), recordNumber: 0 };
}
exports.MessageReveal_MessageRevealDirect = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.key.length !== 0) {
            writer.uint32(10).bytes(message.key);
        }
        if (message.iv.length !== 0) {
            writer.uint32(18).bytes(message.iv);
        }
        if (message.recordNumber !== 0) {
            writer.uint32(24).uint32(message.recordNumber);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageReveal_MessageRevealDirect();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.key = reader.bytes();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.iv = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.recordNumber = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            key: isSet(object.key) ? bytesFromBase64(object.key) : new Uint8Array(0),
            iv: isSet(object.iv) ? bytesFromBase64(object.iv) : new Uint8Array(0),
            recordNumber: isSet(object.recordNumber) ? globalThis.Number(object.recordNumber) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.key.length !== 0) {
            obj.key = base64FromBytes(message.key);
        }
        if (message.iv.length !== 0) {
            obj.iv = base64FromBytes(message.iv);
        }
        if (message.recordNumber !== 0) {
            obj.recordNumber = Math.round(message.recordNumber);
        }
        return obj;
    },
    create(base) {
        return exports.MessageReveal_MessageRevealDirect.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseMessageReveal_MessageRevealDirect();
        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        message.iv = (_b = object.iv) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.recordNumber = (_c = object.recordNumber) !== null && _c !== void 0 ? _c : 0;
        return message;
    },
};
function createBaseMessageReveal_MessageRevealZk() {
    return { proofs: [] };
}
exports.MessageReveal_MessageRevealZk = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.proofs) {
            exports.MessageReveal_ZKProof.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageReveal_MessageRevealZk();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.proofs.push(exports.MessageReveal_ZKProof.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proofs: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.proofs)
                ? object.proofs.map((e) => exports.MessageReveal_ZKProof.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.proofs) === null || _a === void 0 ? void 0 : _a.length) {
            obj.proofs = message.proofs.map((e) => exports.MessageReveal_ZKProof.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.MessageReveal_MessageRevealZk.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseMessageReveal_MessageRevealZk();
        message.proofs = ((_a = object.proofs) === null || _a === void 0 ? void 0 : _a.map((e) => exports.MessageReveal_ZKProof.fromPartial(e))) || [];
        return message;
    },
};
function createBaseMessageReveal_ZKProof() {
    return {
        proofJson: "",
        decryptedRedactedCiphertext: new Uint8Array(0),
        redactedPlaintext: new Uint8Array(0),
        startIdx: 0,
    };
}
exports.MessageReveal_ZKProof = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.proofJson !== "") {
            writer.uint32(10).string(message.proofJson);
        }
        if (message.decryptedRedactedCiphertext.length !== 0) {
            writer.uint32(18).bytes(message.decryptedRedactedCiphertext);
        }
        if (message.redactedPlaintext.length !== 0) {
            writer.uint32(26).bytes(message.redactedPlaintext);
        }
        if (message.startIdx !== 0) {
            writer.uint32(32).uint32(message.startIdx);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseMessageReveal_ZKProof();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.proofJson = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.decryptedRedactedCiphertext = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.redactedPlaintext = reader.bytes();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.startIdx = reader.uint32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            proofJson: isSet(object.proofJson) ? globalThis.String(object.proofJson) : "",
            decryptedRedactedCiphertext: isSet(object.decryptedRedactedCiphertext)
                ? bytesFromBase64(object.decryptedRedactedCiphertext)
                : new Uint8Array(0),
            redactedPlaintext: isSet(object.redactedPlaintext)
                ? bytesFromBase64(object.redactedPlaintext)
                : new Uint8Array(0),
            startIdx: isSet(object.startIdx) ? globalThis.Number(object.startIdx) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.proofJson !== "") {
            obj.proofJson = message.proofJson;
        }
        if (message.decryptedRedactedCiphertext.length !== 0) {
            obj.decryptedRedactedCiphertext = base64FromBytes(message.decryptedRedactedCiphertext);
        }
        if (message.redactedPlaintext.length !== 0) {
            obj.redactedPlaintext = base64FromBytes(message.redactedPlaintext);
        }
        if (message.startIdx !== 0) {
            obj.startIdx = Math.round(message.startIdx);
        }
        return obj;
    },
    create(base) {
        return exports.MessageReveal_ZKProof.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d;
        const message = createBaseMessageReveal_ZKProof();
        message.proofJson = (_a = object.proofJson) !== null && _a !== void 0 ? _a : "";
        message.decryptedRedactedCiphertext = (_b = object.decryptedRedactedCiphertext) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.redactedPlaintext = (_c = object.redactedPlaintext) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        message.startIdx = (_d = object.startIdx) !== null && _d !== void 0 ? _d : 0;
        return message;
    },
};
function createBaseClaimRequestData() {
    return { provider: "", parameters: "", owner: "", timestampS: 0, context: "" };
}
exports.ClaimRequestData = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.provider !== "") {
            writer.uint32(10).string(message.provider);
        }
        if (message.parameters !== "") {
            writer.uint32(18).string(message.parameters);
        }
        if (message.owner !== "") {
            writer.uint32(26).string(message.owner);
        }
        if (message.timestampS !== 0) {
            writer.uint32(32).uint32(message.timestampS);
        }
        if (message.context !== "") {
            writer.uint32(42).string(message.context);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimRequestData();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.provider = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.parameters = reader.string();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.owner = reader.string();
                    continue;
                case 4:
                    if (tag !== 32) {
                        break;
                    }
                    message.timestampS = reader.uint32();
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.context = reader.string();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            provider: isSet(object.provider) ? globalThis.String(object.provider) : "",
            parameters: isSet(object.parameters) ? globalThis.String(object.parameters) : "",
            owner: isSet(object.owner) ? globalThis.String(object.owner) : "",
            timestampS: isSet(object.timestampS) ? globalThis.Number(object.timestampS) : 0,
            context: isSet(object.context) ? globalThis.String(object.context) : "",
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.provider !== "") {
            obj.provider = message.provider;
        }
        if (message.parameters !== "") {
            obj.parameters = message.parameters;
        }
        if (message.owner !== "") {
            obj.owner = message.owner;
        }
        if (message.timestampS !== 0) {
            obj.timestampS = Math.round(message.timestampS);
        }
        if (message.context !== "") {
            obj.context = message.context;
        }
        return obj;
    },
    create(base) {
        return exports.ClaimRequestData.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c, _d, _e;
        const message = createBaseClaimRequestData();
        message.provider = (_a = object.provider) !== null && _a !== void 0 ? _a : "";
        message.parameters = (_b = object.parameters) !== null && _b !== void 0 ? _b : "";
        message.owner = (_c = object.owner) !== null && _c !== void 0 ? _c : "";
        message.timestampS = (_d = object.timestampS) !== null && _d !== void 0 ? _d : 0;
        message.context = (_e = object.context) !== null && _e !== void 0 ? _e : "";
        return message;
    },
};
function createBaseClaimTunnelRequest() {
    return { request: undefined, data: undefined, transcript: [], signatures: undefined, zkEngine: 0 };
}
exports.ClaimTunnelRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.request !== undefined) {
            exports.CreateTunnelRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
        }
        if (message.data !== undefined) {
            exports.ClaimRequestData.encode(message.data, writer.uint32(18).fork()).ldelim();
        }
        for (const v of message.transcript) {
            exports.ClaimTunnelRequest_TranscriptMessage.encode(v, writer.uint32(26).fork()).ldelim();
        }
        if (message.signatures !== undefined) {
            exports.ClaimTunnelRequest_Signatures.encode(message.signatures, writer.uint32(34).fork()).ldelim();
        }
        if (message.zkEngine !== 0) {
            writer.uint32(40).int32(message.zkEngine);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTunnelRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.request = exports.CreateTunnelRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.data = exports.ClaimRequestData.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.transcript.push(exports.ClaimTunnelRequest_TranscriptMessage.decode(reader, reader.uint32()));
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signatures = exports.ClaimTunnelRequest_Signatures.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 40) {
                        break;
                    }
                    message.zkEngine = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            request: isSet(object.request) ? exports.CreateTunnelRequest.fromJSON(object.request) : undefined,
            data: isSet(object.data) ? exports.ClaimRequestData.fromJSON(object.data) : undefined,
            transcript: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.transcript)
                ? object.transcript.map((e) => exports.ClaimTunnelRequest_TranscriptMessage.fromJSON(e))
                : [],
            signatures: isSet(object.signatures) ? exports.ClaimTunnelRequest_Signatures.fromJSON(object.signatures) : undefined,
            zkEngine: isSet(object.zkEngine) ? zKProofEngineFromJSON(object.zkEngine) : 0,
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if (message.request !== undefined) {
            obj.request = exports.CreateTunnelRequest.toJSON(message.request);
        }
        if (message.data !== undefined) {
            obj.data = exports.ClaimRequestData.toJSON(message.data);
        }
        if ((_a = message.transcript) === null || _a === void 0 ? void 0 : _a.length) {
            obj.transcript = message.transcript.map((e) => exports.ClaimTunnelRequest_TranscriptMessage.toJSON(e));
        }
        if (message.signatures !== undefined) {
            obj.signatures = exports.ClaimTunnelRequest_Signatures.toJSON(message.signatures);
        }
        if (message.zkEngine !== 0) {
            obj.zkEngine = zKProofEngineToJSON(message.zkEngine);
        }
        return obj;
    },
    create(base) {
        return exports.ClaimTunnelRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseClaimTunnelRequest();
        message.request = (object.request !== undefined && object.request !== null)
            ? exports.CreateTunnelRequest.fromPartial(object.request)
            : undefined;
        message.data = (object.data !== undefined && object.data !== null)
            ? exports.ClaimRequestData.fromPartial(object.data)
            : undefined;
        message.transcript = ((_a = object.transcript) === null || _a === void 0 ? void 0 : _a.map((e) => exports.ClaimTunnelRequest_TranscriptMessage.fromPartial(e))) || [];
        message.signatures = (object.signatures !== undefined && object.signatures !== null)
            ? exports.ClaimTunnelRequest_Signatures.fromPartial(object.signatures)
            : undefined;
        message.zkEngine = (_b = object.zkEngine) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseClaimTunnelRequest_Signatures() {
    return { requestSignature: new Uint8Array(0) };
}
exports.ClaimTunnelRequest_Signatures = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.requestSignature.length !== 0) {
            writer.uint32(10).bytes(message.requestSignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTunnelRequest_Signatures();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.requestSignature = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            requestSignature: isSet(object.requestSignature) ? bytesFromBase64(object.requestSignature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.requestSignature.length !== 0) {
            obj.requestSignature = base64FromBytes(message.requestSignature);
        }
        return obj;
    },
    create(base) {
        return exports.ClaimTunnelRequest_Signatures.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseClaimTunnelRequest_Signatures();
        message.requestSignature = (_a = object.requestSignature) !== null && _a !== void 0 ? _a : new Uint8Array(0);
        return message;
    },
};
function createBaseClaimTunnelRequest_TranscriptMessage() {
    return { sender: 0, message: new Uint8Array(0), reveal: undefined };
}
exports.ClaimTunnelRequest_TranscriptMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.sender !== 0) {
            writer.uint32(8).int32(message.sender);
        }
        if (message.message.length !== 0) {
            writer.uint32(18).bytes(message.message);
        }
        if (message.reveal !== undefined) {
            exports.MessageReveal.encode(message.reveal, writer.uint32(26).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTunnelRequest_TranscriptMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.sender = reader.int32();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.message = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.reveal = exports.MessageReveal.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            sender: isSet(object.sender) ? transcriptMessageSenderTypeFromJSON(object.sender) : 0,
            message: isSet(object.message) ? bytesFromBase64(object.message) : new Uint8Array(0),
            reveal: isSet(object.reveal) ? exports.MessageReveal.fromJSON(object.reveal) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.sender !== 0) {
            obj.sender = transcriptMessageSenderTypeToJSON(message.sender);
        }
        if (message.message.length !== 0) {
            obj.message = base64FromBytes(message.message);
        }
        if (message.reveal !== undefined) {
            obj.reveal = exports.MessageReveal.toJSON(message.reveal);
        }
        return obj;
    },
    create(base) {
        return exports.ClaimTunnelRequest_TranscriptMessage.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseClaimTunnelRequest_TranscriptMessage();
        message.sender = (_a = object.sender) !== null && _a !== void 0 ? _a : 0;
        message.message = (_b = object.message) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.reveal = (object.reveal !== undefined && object.reveal !== null)
            ? exports.MessageReveal.fromPartial(object.reveal)
            : undefined;
        return message;
    },
};
function createBaseClaimTunnelResponse() {
    return { request: undefined, claim: undefined, error: undefined, signatures: undefined };
}
exports.ClaimTunnelResponse = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.request !== undefined) {
            exports.ClaimTunnelRequest.encode(message.request, writer.uint32(10).fork()).ldelim();
        }
        if (message.claim !== undefined) {
            exports.ProviderClaimData.encode(message.claim, writer.uint32(18).fork()).ldelim();
        }
        if (message.error !== undefined) {
            exports.WitnessErrorData.encode(message.error, writer.uint32(26).fork()).ldelim();
        }
        if (message.signatures !== undefined) {
            exports.ClaimTunnelResponse_Signatures.encode(message.signatures, writer.uint32(34).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTunnelResponse();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.request = exports.ClaimTunnelRequest.decode(reader, reader.uint32());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.claim = exports.ProviderClaimData.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.error = exports.WitnessErrorData.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.signatures = exports.ClaimTunnelResponse_Signatures.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            request: isSet(object.request) ? exports.ClaimTunnelRequest.fromJSON(object.request) : undefined,
            claim: isSet(object.claim) ? exports.ProviderClaimData.fromJSON(object.claim) : undefined,
            error: isSet(object.error) ? exports.WitnessErrorData.fromJSON(object.error) : undefined,
            signatures: isSet(object.signatures) ? exports.ClaimTunnelResponse_Signatures.fromJSON(object.signatures) : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.request !== undefined) {
            obj.request = exports.ClaimTunnelRequest.toJSON(message.request);
        }
        if (message.claim !== undefined) {
            obj.claim = exports.ProviderClaimData.toJSON(message.claim);
        }
        if (message.error !== undefined) {
            obj.error = exports.WitnessErrorData.toJSON(message.error);
        }
        if (message.signatures !== undefined) {
            obj.signatures = exports.ClaimTunnelResponse_Signatures.toJSON(message.signatures);
        }
        return obj;
    },
    create(base) {
        return exports.ClaimTunnelResponse.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        const message = createBaseClaimTunnelResponse();
        message.request = (object.request !== undefined && object.request !== null)
            ? exports.ClaimTunnelRequest.fromPartial(object.request)
            : undefined;
        message.claim = (object.claim !== undefined && object.claim !== null)
            ? exports.ProviderClaimData.fromPartial(object.claim)
            : undefined;
        message.error = (object.error !== undefined && object.error !== null)
            ? exports.WitnessErrorData.fromPartial(object.error)
            : undefined;
        message.signatures = (object.signatures !== undefined && object.signatures !== null)
            ? exports.ClaimTunnelResponse_Signatures.fromPartial(object.signatures)
            : undefined;
        return message;
    },
};
function createBaseClaimTunnelResponse_Signatures() {
    return { witnessAddress: "", claimSignature: new Uint8Array(0), resultSignature: new Uint8Array(0) };
}
exports.ClaimTunnelResponse_Signatures = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.witnessAddress !== "") {
            writer.uint32(10).string(message.witnessAddress);
        }
        if (message.claimSignature.length !== 0) {
            writer.uint32(18).bytes(message.claimSignature);
        }
        if (message.resultSignature.length !== 0) {
            writer.uint32(26).bytes(message.resultSignature);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseClaimTunnelResponse_Signatures();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.witnessAddress = reader.string();
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.claimSignature = reader.bytes();
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.resultSignature = reader.bytes();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            witnessAddress: isSet(object.witnessAddress) ? globalThis.String(object.witnessAddress) : "",
            claimSignature: isSet(object.claimSignature) ? bytesFromBase64(object.claimSignature) : new Uint8Array(0),
            resultSignature: isSet(object.resultSignature) ? bytesFromBase64(object.resultSignature) : new Uint8Array(0),
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.witnessAddress !== "") {
            obj.witnessAddress = message.witnessAddress;
        }
        if (message.claimSignature.length !== 0) {
            obj.claimSignature = base64FromBytes(message.claimSignature);
        }
        if (message.resultSignature.length !== 0) {
            obj.resultSignature = base64FromBytes(message.resultSignature);
        }
        return obj;
    },
    create(base) {
        return exports.ClaimTunnelResponse_Signatures.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b, _c;
        const message = createBaseClaimTunnelResponse_Signatures();
        message.witnessAddress = (_a = object.witnessAddress) !== null && _a !== void 0 ? _a : "";
        message.claimSignature = (_b = object.claimSignature) !== null && _b !== void 0 ? _b : new Uint8Array(0);
        message.resultSignature = (_c = object.resultSignature) !== null && _c !== void 0 ? _c : new Uint8Array(0);
        return message;
    },
};
function createBaseInitRequest() {
    return { clientVersion: 0, signatureType: 0 };
}
exports.InitRequest = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.clientVersion !== 0) {
            writer.uint32(16).int32(message.clientVersion);
        }
        if (message.signatureType !== 0) {
            writer.uint32(24).int32(message.signatureType);
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseInitRequest();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 2:
                    if (tag !== 16) {
                        break;
                    }
                    message.clientVersion = reader.int32();
                    continue;
                case 3:
                    if (tag !== 24) {
                        break;
                    }
                    message.signatureType = reader.int32();
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            clientVersion: isSet(object.clientVersion) ? witnessVersionFromJSON(object.clientVersion) : 0,
            signatureType: isSet(object.signatureType) ? serviceSignatureTypeFromJSON(object.signatureType) : 0,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.clientVersion !== 0) {
            obj.clientVersion = witnessVersionToJSON(message.clientVersion);
        }
        if (message.signatureType !== 0) {
            obj.signatureType = serviceSignatureTypeToJSON(message.signatureType);
        }
        return obj;
    },
    create(base) {
        return exports.InitRequest.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a, _b;
        const message = createBaseInitRequest();
        message.clientVersion = (_a = object.clientVersion) !== null && _a !== void 0 ? _a : 0;
        message.signatureType = (_b = object.signatureType) !== null && _b !== void 0 ? _b : 0;
        return message;
    },
};
function createBaseRPCMessage() {
    return {
        id: 0,
        initRequest: undefined,
        initResponse: undefined,
        connectionTerminationAlert: undefined,
        requestError: undefined,
        createTunnelRequest: undefined,
        createTunnelResponse: undefined,
        disconnectTunnelRequest: undefined,
        disconnectTunnelResponse: undefined,
        tunnelMessage: undefined,
        tunnelDisconnectEvent: undefined,
        claimTunnelRequest: undefined,
        claimTunnelResponse: undefined,
    };
}
exports.RPCMessage = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        if (message.id !== 0) {
            writer.uint32(8).uint64(message.id);
        }
        if (message.initRequest !== undefined) {
            exports.InitRequest.encode(message.initRequest, writer.uint32(18).fork()).ldelim();
        }
        if (message.initResponse !== undefined) {
            exports.Empty.encode(message.initResponse, writer.uint32(26).fork()).ldelim();
        }
        if (message.connectionTerminationAlert !== undefined) {
            exports.WitnessErrorData.encode(message.connectionTerminationAlert, writer.uint32(34).fork()).ldelim();
        }
        if (message.requestError !== undefined) {
            exports.WitnessErrorData.encode(message.requestError, writer.uint32(42).fork()).ldelim();
        }
        if (message.createTunnelRequest !== undefined) {
            exports.CreateTunnelRequest.encode(message.createTunnelRequest, writer.uint32(50).fork()).ldelim();
        }
        if (message.createTunnelResponse !== undefined) {
            exports.Empty.encode(message.createTunnelResponse, writer.uint32(58).fork()).ldelim();
        }
        if (message.disconnectTunnelRequest !== undefined) {
            exports.DisconnectTunnelRequest.encode(message.disconnectTunnelRequest, writer.uint32(66).fork()).ldelim();
        }
        if (message.disconnectTunnelResponse !== undefined) {
            exports.Empty.encode(message.disconnectTunnelResponse, writer.uint32(74).fork()).ldelim();
        }
        if (message.tunnelMessage !== undefined) {
            exports.TunnelMessage.encode(message.tunnelMessage, writer.uint32(82).fork()).ldelim();
        }
        if (message.tunnelDisconnectEvent !== undefined) {
            exports.TunnelDisconnectEvent.encode(message.tunnelDisconnectEvent, writer.uint32(90).fork()).ldelim();
        }
        if (message.claimTunnelRequest !== undefined) {
            exports.ClaimTunnelRequest.encode(message.claimTunnelRequest, writer.uint32(98).fork()).ldelim();
        }
        if (message.claimTunnelResponse !== undefined) {
            exports.ClaimTunnelResponse.encode(message.claimTunnelResponse, writer.uint32(106).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRPCMessage();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 8) {
                        break;
                    }
                    message.id = longToNumber(reader.uint64());
                    continue;
                case 2:
                    if (tag !== 18) {
                        break;
                    }
                    message.initRequest = exports.InitRequest.decode(reader, reader.uint32());
                    continue;
                case 3:
                    if (tag !== 26) {
                        break;
                    }
                    message.initResponse = exports.Empty.decode(reader, reader.uint32());
                    continue;
                case 4:
                    if (tag !== 34) {
                        break;
                    }
                    message.connectionTerminationAlert = exports.WitnessErrorData.decode(reader, reader.uint32());
                    continue;
                case 5:
                    if (tag !== 42) {
                        break;
                    }
                    message.requestError = exports.WitnessErrorData.decode(reader, reader.uint32());
                    continue;
                case 6:
                    if (tag !== 50) {
                        break;
                    }
                    message.createTunnelRequest = exports.CreateTunnelRequest.decode(reader, reader.uint32());
                    continue;
                case 7:
                    if (tag !== 58) {
                        break;
                    }
                    message.createTunnelResponse = exports.Empty.decode(reader, reader.uint32());
                    continue;
                case 8:
                    if (tag !== 66) {
                        break;
                    }
                    message.disconnectTunnelRequest = exports.DisconnectTunnelRequest.decode(reader, reader.uint32());
                    continue;
                case 9:
                    if (tag !== 74) {
                        break;
                    }
                    message.disconnectTunnelResponse = exports.Empty.decode(reader, reader.uint32());
                    continue;
                case 10:
                    if (tag !== 82) {
                        break;
                    }
                    message.tunnelMessage = exports.TunnelMessage.decode(reader, reader.uint32());
                    continue;
                case 11:
                    if (tag !== 90) {
                        break;
                    }
                    message.tunnelDisconnectEvent = exports.TunnelDisconnectEvent.decode(reader, reader.uint32());
                    continue;
                case 12:
                    if (tag !== 98) {
                        break;
                    }
                    message.claimTunnelRequest = exports.ClaimTunnelRequest.decode(reader, reader.uint32());
                    continue;
                case 13:
                    if (tag !== 106) {
                        break;
                    }
                    message.claimTunnelResponse = exports.ClaimTunnelResponse.decode(reader, reader.uint32());
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            id: isSet(object.id) ? globalThis.Number(object.id) : 0,
            initRequest: isSet(object.initRequest) ? exports.InitRequest.fromJSON(object.initRequest) : undefined,
            initResponse: isSet(object.initResponse) ? exports.Empty.fromJSON(object.initResponse) : undefined,
            connectionTerminationAlert: isSet(object.connectionTerminationAlert)
                ? exports.WitnessErrorData.fromJSON(object.connectionTerminationAlert)
                : undefined,
            requestError: isSet(object.requestError) ? exports.WitnessErrorData.fromJSON(object.requestError) : undefined,
            createTunnelRequest: isSet(object.createTunnelRequest)
                ? exports.CreateTunnelRequest.fromJSON(object.createTunnelRequest)
                : undefined,
            createTunnelResponse: isSet(object.createTunnelResponse)
                ? exports.Empty.fromJSON(object.createTunnelResponse)
                : undefined,
            disconnectTunnelRequest: isSet(object.disconnectTunnelRequest)
                ? exports.DisconnectTunnelRequest.fromJSON(object.disconnectTunnelRequest)
                : undefined,
            disconnectTunnelResponse: isSet(object.disconnectTunnelResponse)
                ? exports.Empty.fromJSON(object.disconnectTunnelResponse)
                : undefined,
            tunnelMessage: isSet(object.tunnelMessage) ? exports.TunnelMessage.fromJSON(object.tunnelMessage) : undefined,
            tunnelDisconnectEvent: isSet(object.tunnelDisconnectEvent)
                ? exports.TunnelDisconnectEvent.fromJSON(object.tunnelDisconnectEvent)
                : undefined,
            claimTunnelRequest: isSet(object.claimTunnelRequest)
                ? exports.ClaimTunnelRequest.fromJSON(object.claimTunnelRequest)
                : undefined,
            claimTunnelResponse: isSet(object.claimTunnelResponse)
                ? exports.ClaimTunnelResponse.fromJSON(object.claimTunnelResponse)
                : undefined,
        };
    },
    toJSON(message) {
        const obj = {};
        if (message.id !== 0) {
            obj.id = Math.round(message.id);
        }
        if (message.initRequest !== undefined) {
            obj.initRequest = exports.InitRequest.toJSON(message.initRequest);
        }
        if (message.initResponse !== undefined) {
            obj.initResponse = exports.Empty.toJSON(message.initResponse);
        }
        if (message.connectionTerminationAlert !== undefined) {
            obj.connectionTerminationAlert = exports.WitnessErrorData.toJSON(message.connectionTerminationAlert);
        }
        if (message.requestError !== undefined) {
            obj.requestError = exports.WitnessErrorData.toJSON(message.requestError);
        }
        if (message.createTunnelRequest !== undefined) {
            obj.createTunnelRequest = exports.CreateTunnelRequest.toJSON(message.createTunnelRequest);
        }
        if (message.createTunnelResponse !== undefined) {
            obj.createTunnelResponse = exports.Empty.toJSON(message.createTunnelResponse);
        }
        if (message.disconnectTunnelRequest !== undefined) {
            obj.disconnectTunnelRequest = exports.DisconnectTunnelRequest.toJSON(message.disconnectTunnelRequest);
        }
        if (message.disconnectTunnelResponse !== undefined) {
            obj.disconnectTunnelResponse = exports.Empty.toJSON(message.disconnectTunnelResponse);
        }
        if (message.tunnelMessage !== undefined) {
            obj.tunnelMessage = exports.TunnelMessage.toJSON(message.tunnelMessage);
        }
        if (message.tunnelDisconnectEvent !== undefined) {
            obj.tunnelDisconnectEvent = exports.TunnelDisconnectEvent.toJSON(message.tunnelDisconnectEvent);
        }
        if (message.claimTunnelRequest !== undefined) {
            obj.claimTunnelRequest = exports.ClaimTunnelRequest.toJSON(message.claimTunnelRequest);
        }
        if (message.claimTunnelResponse !== undefined) {
            obj.claimTunnelResponse = exports.ClaimTunnelResponse.toJSON(message.claimTunnelResponse);
        }
        return obj;
    },
    create(base) {
        return exports.RPCMessage.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseRPCMessage();
        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : 0;
        message.initRequest = (object.initRequest !== undefined && object.initRequest !== null)
            ? exports.InitRequest.fromPartial(object.initRequest)
            : undefined;
        message.initResponse = (object.initResponse !== undefined && object.initResponse !== null)
            ? exports.Empty.fromPartial(object.initResponse)
            : undefined;
        message.connectionTerminationAlert =
            (object.connectionTerminationAlert !== undefined && object.connectionTerminationAlert !== null)
                ? exports.WitnessErrorData.fromPartial(object.connectionTerminationAlert)
                : undefined;
        message.requestError = (object.requestError !== undefined && object.requestError !== null)
            ? exports.WitnessErrorData.fromPartial(object.requestError)
            : undefined;
        message.createTunnelRequest = (object.createTunnelRequest !== undefined && object.createTunnelRequest !== null)
            ? exports.CreateTunnelRequest.fromPartial(object.createTunnelRequest)
            : undefined;
        message.createTunnelResponse = (object.createTunnelResponse !== undefined && object.createTunnelResponse !== null)
            ? exports.Empty.fromPartial(object.createTunnelResponse)
            : undefined;
        message.disconnectTunnelRequest =
            (object.disconnectTunnelRequest !== undefined && object.disconnectTunnelRequest !== null)
                ? exports.DisconnectTunnelRequest.fromPartial(object.disconnectTunnelRequest)
                : undefined;
        message.disconnectTunnelResponse =
            (object.disconnectTunnelResponse !== undefined && object.disconnectTunnelResponse !== null)
                ? exports.Empty.fromPartial(object.disconnectTunnelResponse)
                : undefined;
        message.tunnelMessage = (object.tunnelMessage !== undefined && object.tunnelMessage !== null)
            ? exports.TunnelMessage.fromPartial(object.tunnelMessage)
            : undefined;
        message.tunnelDisconnectEvent =
            (object.tunnelDisconnectEvent !== undefined && object.tunnelDisconnectEvent !== null)
                ? exports.TunnelDisconnectEvent.fromPartial(object.tunnelDisconnectEvent)
                : undefined;
        message.claimTunnelRequest = (object.claimTunnelRequest !== undefined && object.claimTunnelRequest !== null)
            ? exports.ClaimTunnelRequest.fromPartial(object.claimTunnelRequest)
            : undefined;
        message.claimTunnelResponse = (object.claimTunnelResponse !== undefined && object.claimTunnelResponse !== null)
            ? exports.ClaimTunnelResponse.fromPartial(object.claimTunnelResponse)
            : undefined;
        return message;
    },
};
function createBaseRPCMessages() {
    return { messages: [] };
}
exports.RPCMessages = {
    encode(message, writer = minimal_1.default.Writer.create()) {
        for (const v of message.messages) {
            exports.RPCMessage.encode(v, writer.uint32(10).fork()).ldelim();
        }
        return writer;
    },
    decode(input, length) {
        const reader = input instanceof minimal_1.default.Reader ? input : minimal_1.default.Reader.create(input);
        let end = length === undefined ? reader.len : reader.pos + length;
        const message = createBaseRPCMessages();
        while (reader.pos < end) {
            const tag = reader.uint32();
            switch (tag >>> 3) {
                case 1:
                    if (tag !== 10) {
                        break;
                    }
                    message.messages.push(exports.RPCMessage.decode(reader, reader.uint32()));
                    continue;
            }
            if ((tag & 7) === 4 || tag === 0) {
                break;
            }
            reader.skipType(tag & 7);
        }
        return message;
    },
    fromJSON(object) {
        return {
            messages: globalThis.Array.isArray(object === null || object === void 0 ? void 0 : object.messages)
                ? object.messages.map((e) => exports.RPCMessage.fromJSON(e))
                : [],
        };
    },
    toJSON(message) {
        var _a;
        const obj = {};
        if ((_a = message.messages) === null || _a === void 0 ? void 0 : _a.length) {
            obj.messages = message.messages.map((e) => exports.RPCMessage.toJSON(e));
        }
        return obj;
    },
    create(base) {
        return exports.RPCMessages.fromPartial(base !== null && base !== void 0 ? base : {});
    },
    fromPartial(object) {
        var _a;
        const message = createBaseRPCMessages();
        message.messages = ((_a = object.messages) === null || _a === void 0 ? void 0 : _a.map((e) => exports.RPCMessage.fromPartial(e))) || [];
        return message;
    },
};
function bytesFromBase64(b64) {
    if (globalThis.Buffer) {
        return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
    }
    else {
        const bin = globalThis.atob(b64);
        const arr = new Uint8Array(bin.length);
        for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
        }
        return arr;
    }
}
function base64FromBytes(arr) {
    if (globalThis.Buffer) {
        return globalThis.Buffer.from(arr).toString("base64");
    }
    else {
        const bin = [];
        arr.forEach((byte) => {
            bin.push(globalThis.String.fromCharCode(byte));
        });
        return globalThis.btoa(bin.join(""));
    }
}
function longToNumber(long) {
    if (long.gt(globalThis.Number.MAX_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
    }
    if (long.lt(globalThis.Number.MIN_SAFE_INTEGER)) {
        throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
    }
    return long.toNumber();
}
if (minimal_1.default.util.Long !== long_1.default) {
    minimal_1.default.util.Long = long_1.default;
    minimal_1.default.configure();
}
function isObject(value) {
    return typeof value === "object" && value !== null;
}
function isSet(value) {
    return value !== null && value !== undefined;
}
